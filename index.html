<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Calculadoras</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
  /* --- Bloco explicativo das calculadoras --- */
  .info-card {
    width: 100%;
    max-width: 720px;
    background: #f7fbff;
    border: 1px solid #e3f2fd;
    border-radius: 12px;
    padding: 16px;
    text-align: left;
    box-shadow: 0 6px 18px rgba(0,0,0,0.04);
  }
  .info-card h3 {
    margin: 0 0 8px 0;
    font-size: 18px;
    line-height: 1.3;
  }
  .info-card p {
    margin: 0 0 12px 0;
    color: #333;
  }
  .info-list {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  .info-item {
    background: #ffffff;
    border: 1px solid #e8eef6;
    border-radius: 10px;
    padding: 12px;
  }
  .info-item strong {
    display: block;
    font-size: 15px;
    margin-bottom: 4px;
  }
  .info-hint {
    font-size: 13px;
    color: #4b5563;
    margin-top: 8px;
    border-left: 3px solid #90caf9;
    padding-left: 10px;
  }
  @media (min-width: 700px) {
    .info-list { grid-template-columns: 1fr 1fr; }
  }

  /* --- Layout geral da p√°gina --- */
  :root {
    --primary: #2196F3;
  }
  body {
    font-family: Arial, sans-serif;
    margin: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  h1 {
    font-size: 22px;
    margin-bottom: 15px;
  }
  h2 {
    font-size: 18px;
    margin-top: 20px;
    margin-bottom: 8px;
  }
  .btn-link {
    display: inline-block;
    width: 100%;
    max-width: 360px;
    padding: 14px 20px;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    color: #fff;
    background-color: var(--primary);
    border: none;
    border-radius: 8px;
    text-decoration: none;
    margin: 15px 0;
    transition: background 0.3s;
  }
  .btn-link:hover {
    background-color: #1976D2;
  }
  .form-group {
    margin-bottom: 8px;
    width: 100%;
    max-width: 320px;
    text-align: left;
  }
  label {
    display: block;
    font-weight: bold;
    margin-bottom: 4px;
  }
  input[type="text"],
  input[type="number"] {
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
    font-size: 16px;
  }
  button {
    width: 100%;
    max-width: 320px;
    padding: 12px;
    font-size: 16px;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    border-radius: 6px;
    margin-top: 10px;
  }
  #result, #resultadoArgila {
    margin-top: 15px;
    font-weight: bold;
    font-size: 16px;
  }
  iframe {
    width: 100%;
    max-width: 360px;
    height: 200px;
    border-radius: 10px;
    margin-top: 10px;
  }
  ul {
    padding-left: 20px;
    text-align: left;
  }
  small {
    color: #4b5563;
    display: block;
    margin-top: 4px;
  }

  /* --- Hero image --- */
  .hero {
    width: 100%;
    max-width: 900px;
    margin-bottom: 12px;
  }
  .hero figure {
    margin: 0;
  }
  .hero img {
  width: 50%;
  height: auto;
  border-radius: 12px;
  display: block;
  margin: 0 auto;
  border: 1px solid #e8eef6;
}
  .hero figcaption {
    font-size: 13px;
    margin-top: 6px;
    color: #4b5563;
  }
  .lead {
    max-width: 900px;
    text-align: left;
    line-height: 1.5;
    margin: 10px 0 18px;
  }
  .lead strong { color: #111; }
  </style>
</head>
<body>
  <h1>Calculadoras de Cer√¢mica <br> C√©sar A. Barbosa</h1>

  <!-- IMAGEM + TEXTO EXPLICATIVO INICIAL -->
  <section class="hero" aria-label="Imagem de abertura">
    <figure>
     <img src="https://raw.githubusercontent.com/Cesarabarbosa/calculadoras/main/Screenshot_2025-08-24-11-24-54-816_com.google.android.apps.photos-edit.jpg" 
     alt="Ceramista medindo cilindro para c√°lculo de argila"> </figure>
  </section>

  <p class="lead">
    Para calcular a quantidade de argila de uma pe√ßa de cer√¢mica, √© necess√°rio conhecer a <strong>altura</strong> e a <strong>largura (di√¢metro)</strong> do cilindro. Isso porque todas as pe√ßas feitas no torno t√™m origem em um cilindro, sabendo suas dimens√µes, conseguimos determinara quantidade de argila a ser utilizada.
    <br><br> <strong>üè∫AH, NO FINAL DA P√ÅGINA TEM UM JOGUINHO ONDE EXPLICA COMO AS FORMAS SURGEM DE UM CILINDRO. ‚úÖ
</strong>    
  </p>



  <!-- BOT√ÉO LINK -->
  <a class="btn-link" href="https://drive.google.com/file/d/1K2Kxr5M6Y2CicycqD1OvRIBImnszhkwr/view?usp=drivesdk" target="_blank" rel="noopener">
    CLIQUE AQUI para baixar uma tabela com alguns pesos e medidas de pe√ßas de cer√¢mica que j√° fizemos.<br>
    OU USE A CALCULADORA ABAIXO üëá
  </a>

  <!-- CALCULADORA DE ARGILA -->
  <h2>Calcule a quantidade de argila <br> para modelar sua pe√ßa</h2>

  <div class="form-group">
    <label for="alturaCilindro">Altura do cilindro (cm):</label>
    <input type="number" id="alturaCilindro" step="0.1" min="0" placeholder="ex.: 20">
  </div>
  <div class="form-group">
    <label for="larguraCilindro">Di√¢metro do cilindro (cm):</label>
    <input type="number" id="larguraCilindro" step="0.1" min="0" placeholder="ex.: 12">
  </div>
  <div class="form-group">
    <label for="espessuraParede">Espessura da parede (mm)</label>
    <input type="number" id="espessuraParede" step="0.1" min="1" max="20" placeholder="ex.: 6">
    <small>Pe√ßas comuns variam de ~4 mm a 10 mm.</small>
  </div>
  <div class="form-group">
    <label for="densidade">Densidade da argila (kg/m¬≥)</label>
    <input type="number" id="densidade" step="50" min="1400" max="2600" value="2000">
    <small>Padr√£o usado: 2000 kg/m¬≥ (ajuste conforme sua massa).</small>
  </div>

  <button type="button" onclick="calcularArgila()">Calcular Argila</button>
  <div id="resultadoArgila" aria-live="polite"></div>

  <!-- CALCULADORA DE ENCOLHIMENTO -->
  <h2>Calcule o encolhimento de uma pe√ßa</h2>
  <form id="calcForm" onsubmit="return false;">
    <div class="form-group">
      <label for="alturaFinal">Altura final desejada (cm):</label>
      <input type="number" id="alturaFinal" name="alturaFinal" step="0.1" min="0" placeholder="ex.: 25">
    </div>
    <div class="form-group">
      <label for="larguraFinal">Largura/Di√¢metro final desejado (cm):</label>
      <input type="number" id="larguraFinal" name="larguraFinal" step="0.1" min="0" placeholder="ex.: 25">
    </div>
    <div class="form-group">
      <label for="encolhimento">% de Encolhimento:</label>
      <input type="number" id="encolhimento" name="encolhimento" step="0.1" min="0" max="30" placeholder="ex.: 12">
    </div>
    <button type="button" onclick="calcularMedidasModelagem()">Calcular</button>
  </form>
  <div id="result" aria-live="polite"></div>

  <!-- LISTA DE FORNECEDORES -->
  <h2>Fornecedores (Taxa de Encolhimento)</h2>
  <ul>
    <li>PASCOAL MASSAS: 12%</li>
    <li>NOVA FARIAS: 16%</li>
    <li>TERRA NOVA: 15%</li>
    <li>RESENDE: 14%</li>
  </ul>

  <!-- BLOCO DE ASSINATURA -->
  <h2>Assine e transforme sua jornada na cer√¢mica!</h2>
  <p>üåü Assinando meus conte√∫dos online, voc√™ entra em um universo completo de aprendizado em cer√¢mica!</p>
  <p>Ao se tornar assinante, voc√™ ter√° acesso a:</p>

  <ul style="text-align:left; max-width:600px;">
    <li>‚úÖ <strong>Mais de 500 aulas exclusivas</strong> ‚Äì organizadas e sempre atualizadas, cobrindo desde t√©cnicas fundamentais at√© experimenta√ß√µes criativas, para voc√™ aprender e evoluir no seu ritmo.</li>
    <li>‚úÖ <strong>Grupo de WhatsApp exclusivo</strong> ‚Äì um espa√ßo para trocar experi√™ncias, tirar d√∫vidas, receber dicas, compartilhar resultados e estar em contato direto com outros apaixonados por cer√¢mica.</li>
    <li>‚úÖ <strong>Acompanhamento cont√≠nuo</strong> ‚Äì conte√∫dos pensados para inspirar, motivar e ajudar voc√™ a avan√ßar, seja iniciando agora ou j√° com experi√™ncia no barro.</li>
  </ul>

  <p>√â uma oportunidade de fazer parte de uma comunidade engajada, aprender com profundidade e ter acesso a um acervo riqu√≠ssimo que vai transformar sua rela√ß√£o com a cer√¢mica.</p>
  <p>üîπ <em>Mais que aulas, voc√™ ter√° um caminho de evolu√ß√£o constante e a chance de viver a cer√¢mica de forma ainda mais intensa.</em></p>

  <p>
    <a class="btn-link" href="https://www.ateliedeceramicabarbosa.com.br/post/assinar-as-aulas-online" target="_blank" rel="noopener">
      üëâ Clique aqui e assine minhas aulas online
    </a>
  </p>

  <script>
    function numero(v) { return Number.isFinite(v) ? v : NaN; }

    function calcularArgila() {
      const altura = numero(parseFloat(document.getElementById("alturaCilindro").value));     // cm
      const diametro = numero(parseFloat(document.getElementById("larguraCilindro").value));  // cm
      const tParede = numero(parseFloat(document.getElementById("espessuraParede").value));   // mm
      const densEl   = document.getElementById("densidade");
      const dens    = densEl ? numero(parseFloat(densEl.value)) : 2000;                       // kg/m¬≥

      const out = document.getElementById("resultadoArgila");

      if ([altura, diametro, tParede].some(isNaN) || altura <= 0 || diametro <= 0 || tParede <= 0) {
        out.innerHTML = "Preencha altura, di√¢metro e espessura da parede com valores v√°lidos.";
        return;
      }
      if (dens < 1000 || dens > 3000) {
        out.innerHTML = "Verifique a densidade informada (valor t√≠pico entre 1600 e 2200 kg/m¬≥).";
        return;
      }

      // Convers√µes: cm -> m, mm -> m
      const h  = altura / 100;
      const D  = diametro / 100;
      const t  = tParede / 1000;

      // Volume lateral (parede delgada): V_lateral ‚âà œÄ * D * t * h
      const V_lateral = Math.PI * D * t * h;

      const V_total = V_lateral; // sem fundo
      const massaKg = V_total * dens; // kg

      out.innerHTML = `
        Quantidade de argila necess√°ria: <strong>${massaKg.toFixed(2)} kg</strong><br>
        <small>Parede: ${ (V_lateral * dens).toFixed(2) } kg ¬∑ Densidade considerada: ${dens.toFixed(0)} kg/m¬≥</small>
      `;
    }

    function calcularMedidasModelagem() {
      const alturaFinal = parseFloat(document.getElementById('alturaFinal').value);
      const larguraFinal = parseFloat(document.getElementById('larguraFinal').value);
      const s = parseFloat(document.getElementById('encolhimento').value); // %

      const out = document.getElementById("result");

      if ([alturaFinal, larguraFinal, s].some(v => isNaN(v))) {
        out.innerHTML = "Preencha todos os campos com n√∫meros v√°lidos.";
        return;
      }
      if (s < 0 || s >= 100) {
        out.innerHTML = "A taxa de encolhimento deve estar entre 0% e 99,9%.";
        return;
      }

      const fator = 1 - (s / 100);
      const alturaModelagem = alturaFinal / fator;
      const larguraModelagem = larguraFinal / fator;

      out.innerHTML =
        'Altura para modelagem: <strong>' + alturaModelagem.toFixed(2) + ' cm</strong><br>' +
        'Largura para modelagem: <strong>' + larguraModelagem.toFixed(2) + ' cm</strong>';
    }
  </script>
  <!-- === INSERIR O JOGO (colar antes de </body>) === -->
<section id="torno-virtual" style="width:80%;max-width:900px;margin:40px auto 24px;">
  <h2 style="font-family:Arial, sans-serif;font-size:18px;margin:0 0 10px;text-align:center;">
    üåÄ Torno Virtual ‚Äì Modelagem por Toque
  </h2>
  <iframe id="torno-frame" title="Torno Virtual" style="width:100%;height:640px;border:1px solid #e8eef6;border-radius:12px;"></iframe>
</section>

<script>
(function(){
  var frame = document.getElementById('torno-frame');
  if(!frame) return;

  // HTML COMPLETO DO JOGO (EXATAMENTE COMO VOC√ä ENVIOU)
  var html = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Simulador de Torno ‚Äì Modelagem por Toque</title>
  <style>
    :root{
      --bg:#0e0f12; --panel:#16181d; --muted:#787f8b; --text:#eef2f7; --accent:#4fd1c5; --btn:#1f232b; --btnBorder:#2a2f39;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(1200px 800px at 50% 110%, #0a0b0e 0%, var(--bg) 55%, #0b0c10 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      overscroll-behavior:none; touch-action:none;
    }
    .wrap{ position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; gap:6px; padding:6px; }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:6px 8px; border-radius:10px; background:linear-gradient(180deg, #14161b, #0f1116);
      font-size:0.8rem;
    }
    header .title{font-weight:700; letter-spacing:.2px; font-size:0.9rem}
    header .hint{color:var(--muted); font-size:.7rem}
    #stage{ position:relative; border-radius:12px; overflow:hidden; background: radial-gradient(40% 60% at 50% 100%, #0c0d11 0%, #0c0d11 35%, #08090c 100%); }
    canvas{ display:block; width:100%; height:100%; }

    .panel-wrap{ position:relative; }
    .panel{
      display:flex; flex-wrap:wrap; gap:4px; align-items:center; justify-content:center;
      background:linear-gradient(180deg, #13161b, #0e1015); border:1px solid var(--btnBorder);
      border-radius:10px; padding:4px; font-size:0.7rem; transition:max-height .2s ease, padding .2s ease, opacity .2s ease;
    }
    .panel.collapsed{ max-height:0; padding:0 4px; overflow:hidden; opacity:.0; }
    .panel-toggle{
      position:absolute; right:8px; top:-14px; transform:translateY(-100%);
      border:1px solid var(--btnBorder); background:linear-gradient(180deg, #1b1f27, #151921);
      color:var(--text); border-radius:8px; font-size:.75rem; padding:2px 6px; cursor:pointer;
    }

    .group{display:flex; align-items:center; gap:4px; background:var(--btn); border:1px solid var(--btnBorder); padding:2px 6px; border-radius:8px}
    .label{font-size:.7rem; color:var(--muted)}
    input[type="range"]{ width:84px; accent-color:var(--accent); height:14px; }
    .btn{
      border:1px solid var(--btnBorder); background:linear-gradient(180deg, #1b1f27, #151921);
      color:var(--text); padding:4px 6px; border-radius:8px; font-weight:600; font-size:0.7rem; cursor:pointer;
    }
    .btn.subtle{ background:#171a21 }
    .btn.toggle.on{ outline:1px solid var(--accent); }
    .save-feedback {
      position:absolute; left:50%; transform:translate(-50%, -50%); top:50%;
      display:none; font-size:0.9rem; font-weight:700; color:var(--accent);
      animation: fade-out 1.2s forwards;
    }
    @keyframes fade-out { 0%{opacity:1; transform:translate(-50%, -50%) scale(1);} 100%{opacity:0; transform:translate(-50%, -50%) scale(1.2);} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">üåÄ Torno Virtual</div>
      <div class="hint">Toque na altura e arraste na horizontal. Use ‚öôÔ∏è para abrir/fechar os controles. Use üíæ para salvar uma foto, poste o resultado e maque @cesaraugustobarbosa</div>
    </header>

    <div id="stage"><canvas id="c"></canvas><span id="save-feedback" class="save-feedback">‚úì</span></div>

    <div class="panel-wrap">
      <button id="togglePanel" class="panel-toggle" aria-expanded="true">‚öôÔ∏è</button>
      <div id="panel" class="panel">
        <div class="group"><span class="label">Dedo</span><input id="toolSize" type="range" min="8" max="48" value="22" /></div>
        <div class="group"><span class="label">For√ßa</span><input id="strength" type="range" min="1" max="100" value="55" /></div>
        <div class="group"><span class="label">Prato</span><input id="speed" type="range" min="0" max="120" value="60" /></div>
        <div class="group"><span class="label">Faixa</span><input id="bandWidth" type="range" min="4" max="40" value="14" /></div>
        <div class="group"><span class="label">Altura</span><input id="heightScale" type="range" min="70" max="150" value="100" /></div>
        <button class="btn toggle on" id="lockBtn" aria-pressed="true" title="Altura fixa">Fixo</button>
        <button class="btn" id="undoBtn" title="Desfazer (Ctrl+Z)">‚Ü∂</button>
        <button class="btn" id="redoBtn" title="Refazer (Ctrl+Y / Ctrl+Shift+Z)">‚Ü∑</button>
        <button class="btn" id="smoothBtn" title="Alisar">Alisar</button>
        <button class="btn subtle" id="resetBtn" title="Resetar forma">Reset</button>
        <button class="btn" id="saveBtn" title="Salvar PNG">üíæ</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ==== DOM
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const toolSizeEl = document.getElementById('toolSize');
  const strengthEl = document.getElementById('strength');
  const speedEl = document.getElementById('speed');
  const bandEl = document.getElementById('bandWidth');
  const heightEl = document.getElementById('heightScale');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const smoothBtn = document.getElementById('smoothBtn');
  const saveBtn = document.getElementById('saveBtn');
  const saveFeedback = document.getElementById('save-feedback');
  const lockBtn = document.getElementById('lockBtn');
  const togglePanelBtn = document.getElementById('togglePanel');
  const panel = document.getElementById('panel');

  // ==== Estado
  let W=0,H=0,DPR=1;
  let cx=0, baseY=0, heightPx=0, baseHeightPx=0, maxR=0;
  let N = 220; let heightScale = 1; // 1.0 = 100%
  let r = new Float32Array(N);
  let baseR = 0;

  let lockHeight = true;  // Altura fixa
  let iyLock = -1;        // √≠ndice travado durante o tra√ßo
  let startY = 0;         // y inicial do toque (px)
  const HYSTERESIS_PX = 18;       // toler√¢ncia para n√£o saltar de faixa
  const V_LOCK_SMOOTH = 0.25;     // suaviza√ß√£o ao mudar de altura

  // Undo/redo
  const MAX_STACK=30; let undoStack=[]; let redoStack=[]; const EPS=1e-6;
  const arraysEqualApprox=(a,b)=>{ if(!a||!b||a.length!==b.length) return false; for(let i=0;i<a.length;i++){ if(Math.abs(a[i]-b[i])>EPS) return false; } return true; };
  const pushUndo=()=>{ if(!undoStack.length || !arraysEqualApprox(r, undoStack[undoStack.length-1])){ undoStack.push(r.slice()); if(undoStack.length>MAX_STACK) undoStack.shift(); redoStack.length=0; } };
  const popUndo=()=>{ if(!undoStack.length) return; redoStack.push(r.slice()); r = undoStack.pop(); };
  const popRedo=()=>{ if(!redoStack.length) return; undoStack.push(r.slice()); r = redoStack.pop(); };

  // ==== Layout + preserva√ß√£o de forma
  function resize(){
    const oldR = r.slice(); const oldN = N;
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    const stage = document.getElementById('stage');
    const rect = stage.getBoundingClientRect();
    W = Math.max(320, rect.width|0);
    H = Math.max(320, rect.height|0);
    canvas.width = (W*DPR)|0; canvas.height=(H*DPR)|0; canvas.style.width=W+'px'; canvas.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    baseHeightPx = Math.min(H*0.70, W*0.9);
    heightPx = baseHeightPx * heightScale;
    cx = W*0.5; baseY = H*0.80; maxR = Math.min(W*0.38, H*0.38);
    baseR = Math.min(maxR*0.78, 160);

    const screenRatio = Math.max(W, H) / Math.min(W, H);
    N = Math.max(180, Math.min(320, Math.floor(220 + 60*(screenRatio-1))));
    const newR = new Float32Array(N);

    if(oldN>0 && oldR.some(v=>v>0)){
      for(let i=0;i<N;i++){
        const t = i/(N-1); const x=t*(oldN-1); const i0=Math.floor(x); const i1=Math.min(oldN-1,i0+1); const a=x-i0;
        newR[i] = (1-a)*oldR[i0] + a*oldR[i1];
      }
      r = newR;
    } else {
      r = new Float32Array(N); initShape();
    }
  }

  function initShape(){
    for(let i=0;i<N;i++){
      const t=i/(N-1); const ease=0.06*Math.sin(t*Math.PI*0.9);
      r[i] = baseR*(1-0.08*t) + ease*baseR; if(i<N*0.03) r[i]*=1.02;
    }
  }

  const yOf = (i)=> baseY - (i/(N-1))*heightPx;

  function smoothLocal(center, radiusIdx, iter=1, k=0.18){
    for(let it=0; it<iter; it++){
      const prev = r.slice();
      const i0 = Math.max(1, center - radiusIdx);
      const i1 = Math.min(N-2, center + radiusIdx);
      for(let i=i0;i<=i1;i++) r[i] = prev[i]*(1-2*k) + (prev[i-1]+prev[i+1])*k;
      r[i0-1] = Math.max(6, Math.min(maxR, r[i0-1]||r[i0]));
      r[i1+1] = Math.max(6, Math.min(maxR*0.9, r[i1+1]||r[i1]));
    }
  }

  // ==== Intera√ß√£o
  let drawing=false, lastX=0, activePointer=-1;
  canvas.addEventListener('pointerdown', (e)=>{
    activePointer = e.pointerId; canvas.setPointerCapture(activePointer);
    drawing=true; lastX=e.clientX; pushUndo();
    const rect = canvas.getBoundingClientRect();
    startY = e.clientY - rect.top;
    // mapeamento: topo (menor y) => √≠ndices altos; base (maior y) => √≠ndices baixos
    iyLock = Math.round(((baseY - (e.clientY - rect.top))/heightPx)*(N-1));
    iyLock = Math.max(0, Math.min(N-1, iyLock));
  });
  const finishDraw=()=>{ if(activePointer!==-1){ canvas.releasePointerCapture(activePointer);} activePointer=-1; drawing=false; lastX=0; iyLock=-1; };
  canvas.addEventListener('pointerup', finishDraw);
  canvas.addEventListener('pointercancel', finishDraw);

  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || e.pointerId!==activePointer) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top; const dx = (x - lastX); lastX = x;

    const spanPx = parseInt(toolSizeEl.value,10);
    const bandPx = parseInt(bandEl.value,10);
    const spanIdx = Math.max(2, Math.round((spanPx/Math.max(1,heightPx))*(N-1)));
    const bandIdx = Math.max(1, Math.round((bandPx/Math.max(1,heightPx))*(N-1)));
    let strength = parseInt(strengthEl.value,10)/600; if(e.pressure && e.pressure>0) strength *= (0.6 + 0.8*e.pressure);

    let iyRaw = Math.round(((baseY - y)/heightPx)*(N-1)); iyRaw = Math.max(0, Math.min(N-1, iyRaw));
    let iy;
    if(lockHeight && iyLock>=0){
      if (Math.abs((e.clientY - rect.top) - startY) <= HYSTERESIS_PX){ iy = iyLock; }
      else { iyLock = Math.round(iyLock*(1 - V_LOCK_SMOOTH) + iyRaw*V_LOCK_SMOOTH); iy = iyLock; }
    } else { iy = iyRaw; }

    const radius = bandIdx;
    for(let k=-radius;k<=radius;k++){
      const i = iy + k; if(i<0||i>=N) continue;
      const w = Math.exp(-0.5*(k/radius)*(k/radius));
      r[i] += dx * strength * w;
      const rmin = 6 + Math.max(0, 10*(1 - i/(N-1)));
      const rmax = maxR * (i<(N-1)?1:0.9);
      if(r[i]<rmin) r[i]=rmin; if(r[i]>rmax) r[i]=rmax;
    }
    smoothLocal(iy, Math.max(1, Math.ceil(spanIdx*0.6)), 1, 0.16);
  }, {passive:false});

  // ==== Controles
  document.getElementById('togglePanel').onclick = ()=>{
    panel.classList.toggle('collapsed');
    const expanded = !panel.classList.contains('collapsed');
    togglePanelBtn.setAttribute('aria-expanded', String(expanded));
  };

  lockBtn.onclick = ()=>{
    lockHeight = !lockHeight;
    lockBtn.classList.toggle('on', lockHeight);
    lockBtn.setAttribute('aria-pressed', String(lockHeight));
  };
  undoBtn.onclick = ()=> popUndo();
  redoBtn.onclick = ()=> popRedo();
  resetBtn.onclick = ()=>{ pushUndo(); initShape(); };
  smoothBtn.onclick = ()=>{ const center=Math.floor((N-1)/2); smoothLocal(center, Math.floor(N/2), 2, 0.15); };
  saveBtn.onclick = ()=>{
    const link = document.createElement('a'); link.download = 'torno-virtual.png'; link.href = canvas.toDataURL('image/png'); link.click();
    saveFeedback.style.display='block'; saveFeedback.style.animation='none'; void saveFeedback.offsetWidth; saveFeedback.style.animation='fade-out 1.2s forwards';
    setTimeout(()=>{ saveFeedback.style.display='none'; }, 1200);
  };

  // Atalhos de teclado
  window.addEventListener('keydown', (e)=>{
    const k=e.key;
    if ((e.ctrlKey||e.metaKey) && !e.shiftKey && (k==='z'||k==='Z')){ e.preventDefault(); popUndo(); }
    else if ((e.ctrlKey||e.metaKey) && (k==='y'||k==='Y')){ e.preventDefault(); popRedo(); }
    else if ((e.ctrlKey||e.metaKey) && e.shiftKey && (k==='z'||k==='Z')){ e.preventDefault(); popRedo(); }
  });

  // ==== Render
  let tPrev=0, spin=0;
  function draw(ts){
    const dt = Math.min(32, (ts - (tPrev||ts))) / 1000; tPrev=ts;
    const rpm = parseInt(speedEl.value,10); spin += (rpm * 2*Math.PI / 60) * dt;
    ctx.clearRect(0,0,W,H);
    drawGround(); drawWheel(spin); drawClay(spin);
    requestAnimationFrame(draw);
  }
  function drawGround(){
    const g=ctx.createRadialGradient(W*0.5,H*0.98,20,W*0.5,H*1.02,Math.max(W,H));
    g.addColorStop(0,'rgba(0,0,0,0.0)'); g.addColorStop(1,'rgba(0,0,0,0.6)');
    ctx.fillStyle=g; ctx.fillRect(0,H*0.75,W,H*0.25);
  }
  function drawWheel(angle){
    const y=baseY+8; const R=Math.min(maxR*1.1,220);
    const grad=ctx.createRadialGradient(cx,y,R*0.2,cx,y,R); grad.addColorStop(0,'#323640'); grad.addColorStop(1,'#1a1d23');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.ellipse(cx,y,R,R*0.25,0,0,Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(cx,y); ctx.scale(1,0.25); ctx.rotate(angle);
    ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2;
    for(let i=0;i<10;i++){ ctx.rotate(Math.PI/5); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(R*0.9,0); ctx.stroke(); }
    ctx.restore();
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(cx,y,Math.min(r[0]*1.05,R*0.9),R*0.20,0,0,Math.PI*2); ctx.fill();
  }
  function drawClay(angle){
    const Rmax=Math.max(...r); const left=cx-Rmax-6, right=cx+Rmax+6;
    ctx.beginPath();
    for(let i=0;i<N;i++){ const x=cx-r[i]; const y=yOf(i); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    for(let i=N-1;i>=0;i--){ const x=cx+r[i]; const y=yOf(i); ctx.lineTo(x,y); }
    ctx.closePath();
    const c0='#5b463f',c1='#8f6f64',c2='#d5b8ad'; const center=0.5+0.42*Math.sin(angle*1.2);
    const g=ctx.createLinearGradient(left,0,right,0); const w=0.10;
    g.addColorStop(0.00,c0); g.addColorStop(Math.max(0.0,center-2.5*w),c1);
    g.addColorStop(Math.max(0.0,center-1.2*w),c2); g.addColorStop(Math.min(1.0,center+1.2*w),c1); g.addColorStop(1.00,c0);
    ctx.fillStyle=g; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.2; ctx.stroke();
    const rt=r[N-1]; const yt=yOf(N-1)-0.5;
    const eGrad=ctx.createRadialGradient(cx,yt,rt*0.2,cx,yt,rt);
    eGrad.addColorStop(0,'rgba(0,0,0,0.25)'); eGrad.addColorStop(1,'rgba(0,0,0,0.0)');
    ctx.fillStyle=eGrad; ctx.beginPath(); ctx.ellipse(cx,yt,rt,rt*0.18,0,0,Math.PI*2); ctx.fill();
  }

  // ==== Boot
  let initialized=false;
  window.addEventListener('resize', ()=>{
    const prevInit=initialized; initialized=false; resize(); initialized=prevInit;
    const suggestedBand=Math.round(Math.max(8, Math.min(28, heightPx*0.03)));
    const band=Math.max(4, Math.min(40, suggestedBand));
    const prev=parseInt(bandEl.value,10);
    if(!Number.isFinite(prev) || prev===14) bandEl.value=band;
  });
  heightEl.addEventListener('input', ()=>{
    const v=parseInt(heightEl.value,10)||100; heightScale=Math.max(0.5, Math.min(2.0, v/100));
    heightPx = baseHeightPx * heightScale;
  });
  resize(); if(!initialized){ initShape(); pushUndo(); initialized=true; }
  requestAnimationFrame(draw);
})();
<\/script>
</body>
</html>`;

  // Escreve no iframe (usa srcdoc quando dispon√≠vel)
  if ('srcdoc' in frame) {
    frame.srcdoc = html;
  } else {
    var doc = frame.contentWindow.document;
    doc.open(); doc.write(html); doc.close();
  }
})();
</script>
<!-- === /INSERIR O JOGO === -->
</body>
</html>
  