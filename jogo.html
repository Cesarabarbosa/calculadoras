<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Simulador de Torno ‚Äì Desafio de Forma</title>
  <style>
    :root{
      --bg:#0e0f12; --panel:#16181d; --muted:#787f8b; --text:#eef2f7; --accent:#4fd1c5; --btn:#1f232b; --btnBorder:#2a2f39;
      --good:#49d17d; --warn:#e2b14f; --bad:#ef6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(1200px 800px at 50% 110%, #0a0b0e 0%, var(--bg) 55%, #0b0c10 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
      overscroll-behavior:none; touch-action:none;
    }
    .wrap{ position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; gap:6px; padding:6px; }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:6px 8px; border-radius:10px; background:linear-gradient(180deg, #14161b, #0f1116);
      font-size:0.8rem;
    }
    header .title{font-weight:700; letter-spacing:.2px; font-size:0.9rem}
    header .hint{color:var(--muted); font-size:.7rem}
    #stage{ position:relative; border-radius:12px; overflow:hidden; background: radial-gradient(40% 60% at 50% 100%, #0c0d11 0%, #0c0d11 35%, #08090c 100%); }
    canvas{ display:block; width:100%; height:100%; }

    /* Pr√©via do alvo */
    .preview{
      position:absolute; right:8px; top:8px; width:140px; height:140px;
      border-radius:10px; border:1px solid var(--btnBorder);
      background:linear-gradient(180deg, #12151a, #0e1015);
      display:flex; flex-direction:column; padding:6px; gap:4px; pointer-events:none;
    }
    .preview .head{ display:flex; align-items:center; justify-content:space-between; font-size:.68rem; color:var(--muted) }
    .preview canvas{ width:100%; height:100%; border-radius:8px; background:#0a0c10; }

    .panel-wrap{ position:relative; }
    .panel{
      display:flex; flex-wrap:wrap; gap:4px; align-items:center; justify-content:center;
      background:linear-gradient(180deg, #13161b, #0e1015); border:1px solid var(--btnBorder);
      border-radius:10px; padding:4px; font-size:0.7rem; transition:max-height .2s ease, padding .2s ease, opacity .2s ease;
    }
    .panel.collapsed{ max-height:0; padding:0 4px; overflow:hidden; opacity:.0; }
    .panel-toggle{
      position:absolute; right:8px; top:-14px; transform:translateY(-100%);
      border:1px solid var(--btnBorder); background:linear-gradient(180deg, #1b1f27, #151921);
      color:var(--text); border-radius:8px; font-size:.75rem; padding:2px 6px; cursor:pointer;
    }

    .group{display:flex; align-items:center; gap:4px; background:var(--btn); border:1px solid var(--btnBorder); padding:2px 6px; border-radius:8px}
    .label{font-size:.7rem; color:var(--muted)}
    input[type="range"]{ width:84px; accent-color:var(--accent); height:14px; }
    .btn{
      border:1px solid var(--btnBorder); background:linear-gradient(180deg, #1b1f27, #151921);
      color:var(--text); padding:4px 6px; border-radius:8px; font-weight:600; font-size:0.7rem; cursor:pointer;
    }
    .btn.subtle{ background:#171a21 }
    .btn.toggle.on{ outline:1px solid var(--accent); }
    .save-feedback {
      position:absolute; left:50%; transform:translate(-50%, -50%); top:50%;
      display:none; font-size:0.9rem; font-weight:700; color:var(--accent);
      animation: fade-out 1.2s forwards;
    }
    @keyframes fade-out { 0%{opacity:1; transform:translate(-50%, -50%) scale(1);} 100%{opacity:0; transform:translate(-50%, -50%) scale(1.2);} }

    .score-chip{
      margin-left:6px; padding:3px 8px; border-radius:999px; font-weight:700; font-size:.72rem;
      border:1px solid var(--btnBorder); background:#13161b;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
     <div class="title">üåÄ Torno Virtual ‚Äì Desafio de Forma</div>
      <div class="hint">Se consguir copiar o alvo e tiver 100% vai ganhar 1 ano de assinatura. Use ‚öôÔ∏è para abrir os controles. Copie a forma-alvo no canto.</div>
      <div id="score" class="score-chip">Quando achar que est√° bom aperte ‚úÖ OK</div>
    </header>

    <div id="stage">
      <canvas id="c"></canvas>
      <div class="preview" aria-hidden="true">
        <div class="head"><span>üéØ Alvo</span><span id="seedTxt">‚Äî</span></div>
        <canvas id="prev"></canvas>
      </div>
      <span id="save-feedback" class="save-feedback">‚úì</span>
    </div>

    <div class="panel-wrap">
      <button id="togglePanel" class="panel-toggle" aria-expanded="true">‚öôÔ∏è</button>
      <div id="panel" class="panel">
        <div class="group"><span class="label">Dedo</span><input id="toolSize" type="range" min="8" max="48" value="22" /></div>
        <div class="group"><span class="label">For√ßa</span><input id="strength" type="range" min="1" max="100" value="55" /></div>
        <div class="group"><span class="label">Prato</span><input id="speed" type="range" min="0" max="120" value="60" /></div>
        <div class="group"><span class="label">Faixa</span><input id="bandWidth" type="range" min="4" max="40" value="14" /></div>
        <div class="group"><span class="label">Altura</span><input id="heightScale" type="range" min="1" max="100" value="70" /></div>

        <button class="btn toggle on" id="lockBtn" aria-pressed="true" title="Altura fixa">Fixo</button>
        <button class="btn" id="undoBtn" title="Desfazer (Ctrl+Z)">‚Ü∂</button>
        <button class="btn" id="redoBtn" title="Refazer (Ctrl+Y / Ctrl+Shift+Z)">‚Ü∑</button>
        <button class="btn" id="smoothBtn" title="Alisar">Alisar</button>
        <button class="btn subtle" id="resetBtn" title="Resetar forma">Reset</button>
        <button class="btn" id="saveBtn" title="Salvar PNG da pe√ßa">üíæ</button>

        <!-- Desafio -->
        <button class="btn" id="newTargetBtn" title="Novo desafio">üéØ Novo</button>
        <button class="btn" id="okBtn" title="Avaliar e baixar compara√ß√£o">‚úÖ OK</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ==== DOM
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const prevCanvas = document.getElementById('prev');
  const prevCtx = prevCanvas.getContext('2d');

  const toolSizeEl = document.getElementById('toolSize');
  const strengthEl = document.getElementById('strength');
  const speedEl = document.getElementById('speed');
  const bandEl = document.getElementById('bandWidth');
  const heightEl = document.getElementById('heightScale');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const smoothBtn = document.getElementById('smoothBtn');
  const saveBtn = document.getElementById('saveBtn');
  const okBtn = document.getElementById('okBtn');
  const newTargetBtn = document.getElementById('newTargetBtn');

  const saveFeedback = document.getElementById('save-feedback');
  const lockBtn = document.getElementById('lockBtn');
  const togglePanelBtn = document.getElementById('togglePanel');
  const panel = document.getElementById('panel');
  const scoreChip = document.getElementById('score');
  const seedTxt = document.getElementById('seedTxt');

  // ==== Estado
  let W=0,H=0,DPR=1;
  let cx=0, baseY=0, heightPx=0, baseHeightPx=0, maxR=0;
  let N = 220; let heightScale = 1; // 1.0 = 100%
  let r = new Float32Array(N);
  let baseR = 0;

  // Alvo do desafio
  let rTarget = new Float32Array(N);
  let targetSeed = 0;

  let lockHeight = true;  // Altura fixa
  let iyLock = -1;        // √≠ndice travado durante o tra√ßo
  let startY = 0;         // y inicial do toque (px)
  const HYSTERESIS_PX = 18;
  const V_LOCK_SMOOTH = 0.25;

  // Undo/redo
  const MAX_STACK=30; let undoStack=[]; let redoStack=[]; const EPS=1e-6;
  const arraysEqualApprox=(a,b)=>{ if(!a||!b||a.length!==b.length) return false; for(let i=0;i<a.length;i++){ if(Math.abs(a[i]-b[i])>EPS) return false; } return true; };
  const pushUndo=()=>{ if(!undoStack.length || !arraysEqualApprox(r, undoStack[undoStack.length-1])){ undoStack.push(r.slice()); if(undoStack.length>MAX_STACK) undoStack.shift(); redoStack.length=0; } };
  const popUndo=()=>{ if(!undoStack.length) return; redoStack.push(r.slice()); r = undoStack.pop(); };
  const popRedo=()=>{ if(!redoStack.length) return; undoStack.push(r.slice()); r = redoStack.pop(); };

  // ==== Layout + preserva√ß√£o de forma
  function resize(){
    const oldR = r.slice(); const oldN = N;
    const oldT = rTarget.slice();

    DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    const stage = document.getElementById('stage');
    const rect = stage.getBoundingClientRect();
    W = Math.max(320, rect.width|0);
    H = Math.max(320, rect.height|0);
    canvas.width = (W*DPR)|0; canvas.height=(H*DPR)|0; canvas.style.width=W+'px'; canvas.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    baseHeightPx = Math.min(H*0.70, W*0.9);
    heightPx = baseHeightPx * heightScale;
    cx = W*0.5; baseY = H*0.80; maxR = Math.min(W*0.38, H*0.38);
    baseR = Math.min(maxR*0.78, 160);

    // N adaptativo
    const screenRatio = Math.max(W, H) / Math.min(W, H);
    N = Math.max(180, Math.min(320, Math.floor(220 + 60*(screenRatio-1))));
    const newR = new Float32Array(N);
    const newT = new Float32Array(N);

    // reamostrar r
    if(oldN>0 && oldR.some(v=>v>0)){
      for(let i=0;i<N;i++){
        const t = i/(N-1); const x=t*(oldN-1); const i0=Math.floor(x); const i1=Math.min(oldN-1,i0+1); const a=x-i0;
        newR[i] = (1-a)*oldR[i0] + a*oldR[i1];
      }
      r = newR;
    } else {
      r = new Float32Array(N); initShape();
    }
    // reamostrar alvo
    if(oldN>0 && oldT.some(v=>v>0)){
      for(let i=0;i<N;i++){
        const t = i/(N-1); const x=t*(oldN-1); const i0=Math.floor(x); const i1=Math.min(oldN-1,i0+1); const a=x-i0;
        newT[i] = (1-a)*oldT[i0] + a*oldT[i1];
      }
      rTarget = newT;
    } else {
      rTarget = new Float32Array(N);
      generateTarget(); // inicial
    }

    // canvas da pr√©via
    prevCanvas.width = 300; prevCanvas.height = 110; // fixo (interno); CSS cuida da escala
  }

  function initShape(){
    for(let i=0;i<N;i++){
      const t=i/(N-1); const ease=0.06*Math.sin(t*Math.PI*0.9);
      r[i] = baseR*(1-0.08*t) + ease*baseR; if(i<N*0.03) r[i]*=1.02;
    }
  }

  const yOf = (i)=> baseY - (i/(N-1))*heightPx;

  function smoothArray(arr, iter=2, k=0.18){
    const n=arr.length;
    for(let it=0; it<iter; it++){
      const prev = arr.slice();
      for(let i=1;i<n-1;i++) arr[i] = prev[i]*(1-2*k) + (prev[i-1]+prev[i+1])*k;
    }
  }

  function smoothLocal(center, radiusIdx, iter=1, k=0.18){
    for(let it=0; it<iter; it++){
      const prev = r.slice();
      const i0 = Math.max(1, center - radiusIdx);
      const i1 = Math.min(N-2, center + radiusIdx);
      for(let i=i0;i<=i1;i++) r[i] = prev[i]*(1-2*k) + (prev[i-1]+prev[i+1])*k;
      r[i0-1] = Math.max(6, Math.min(maxR, r[i0-1]||r[i0]));
      r[i1+1] = Math.max(6, Math.min(maxR*0.9, r[i1+1]||r[i1]));
    }
  }

  // ==== Gera√ß√£o do ALVO (formas variadas)
  function rand(seed){ // LCG simples para repetibilidade
    let s = seed >>> 0;
    return ()=> (s = (s*1664525 + 1013904223)>>>0, (s/4294967296));
  }
  function generateTarget(seed=Date.now()|0){
    targetSeed = seed;
    seedTxt.textContent = '#'+(seed % 10000).toString().padStart(4,'0');

    const rnd = rand(seed);
    const base = new Float32Array(N);
    const baseRadius = baseR * (0.86 + 0.08*rnd()); // base semelhante ao usu√°rio
    for(let i=0;i<N;i++){
      const t=i/(N-1);
      // perfil base levemente afunilado
      base[i] = baseRadius*(1 - 0.10*t);
    }
    // acrescentar "barrigas"/"pesco√ßo"
    const bumps = 2 + (rnd()<0.5?1:0);
    for(let b=0;b<bumps;b++){
      const center = 0.15 + 0.7*rnd(); // ao longo da altura
      const width  = 0.05 + 0.18*rnd();
      const amp    = (rnd()<0.5?1:-1) * baseRadius * (0.05 + 0.08*rnd());
      for(let i=0;i<N;i++){
        const t=i/(N-1);
        const g = Math.exp(-0.5*((t-center)/width)**2);
        base[i] += amp * g;
      }
    }
    // opcional: boca estreita
    if(rnd()<0.6){
      for(let i=Math.floor(N*0.85); i<N; i++){
        const f = (i - N*0.85)/(N*0.15);
        base[i] *= (0.88 - 0.10*f);
      }
    }
    // limites
    for(let i=0;i<N;i++){
      const rmin = 6 + Math.max(0, 10*(1 - i/(N-1)));
      const rmax = maxR * (i<(N-1)?1:0.9);
      base[i] = Math.max(rmin, Math.min(rmax, base[i]));
    }
    smoothArray(base, 3, 0.16);
    rTarget = base;
  }

  // ==== Intera√ß√£o
  let drawing=false, lastX=0, activePointer=-1;
  canvas.addEventListener('pointerdown', (e)=>{
    activePointer = e.pointerId; canvas.setPointerCapture(activePointer);
    drawing=true; lastX=e.clientX; pushUndo();
    const rect = canvas.getBoundingClientRect();
    startY = e.clientY - rect.top;
    // mapeamento: topo (menor y) => √≠ndices altos; base (maior y) => √≠ndices baixos
    iyLock = Math.round(((baseY - (e.clientY - rect.top))/heightPx)*(N-1));
    iyLock = Math.max(0, Math.min(N-1, iyLock));
  });
  const finishDraw=()=>{ if(activePointer!==-1){ canvas.releasePointerCapture(activePointer);} activePointer=-1; drawing=false; lastX=0; iyLock=-1; };
  canvas.addEventListener('pointerup', finishDraw);
  canvas.addEventListener('pointercancel', finishDraw);

  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || e.pointerId!==activePointer) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top; const dx = (x - lastX); lastX = x;

    const spanPx = parseInt(toolSizeEl.value,10);
    const bandPx = parseInt(bandEl.value,10);
    const spanIdx = Math.max(2, Math.round((spanPx/Math.max(1,heightPx))*(N-1)));
    const bandIdx = Math.max(1, Math.round((bandPx/Math.max(1,heightPx))*(N-1)));
    let strength = parseInt(strengthEl.value,10)/600; if(e.pressure && e.pressure>0) strength *= (0.6 + 0.8*e.pressure);

    let iyRaw = Math.round(((baseY - y)/heightPx)*(N-1)); iyRaw = Math.max(0, Math.min(N-1, iyRaw));
    let iy;
    if(lockHeight && iyLock>=0){
      if (Math.abs((e.clientY - rect.top) - startY) <= HYSTERESIS_PX){ iy = iyLock; }
      else { iyLock = Math.round(iyLock*(1 - V_LOCK_SMOOTH) + iyRaw*V_LOCK_SMOOTH); iy = iyLock; }
    } else { iy = iyRaw; }

    const radius = bandIdx;
    for(let k=-radius;k<=radius;k++){
      const i = iy + k; if(i<0||i>=N) continue;
      const w = Math.exp(-0.5*(k/radius)*(k/radius));
      r[i] += dx * strength * w;
      const rmin = 6 + Math.max(0, 10*(1 - i/(N-1)));
      const rmax = maxR * (i<(N-1)?1:0.9);
      if(r[i]<rmin) r[i]=rmin; if(r[i]>rmax) r[i]=rmax;
    }
    smoothLocal(iy, Math.max(1, Math.ceil(spanIdx*0.6)), 1, 0.16);
  }, {passive:false});

  // ==== Controles
  document.getElementById('togglePanel').onclick = ()=>{
    panel.classList.toggle('collapsed');
    const expanded = !panel.classList.contains('collapsed');
    togglePanelBtn.setAttribute('aria-expanded', String(expanded));
  };

  lockBtn.onclick = ()=>{
    lockHeight = !lockHeight;
    lockBtn.classList.toggle('on', lockHeight);
    lockBtn.setAttribute('aria-pressed', String(lockHeight));
  };
  undoBtn.onclick = ()=> popUndo();
  redoBtn.onclick = ()=> popRedo();
  resetBtn.onclick = ()=>{ pushUndo(); initShape(); };
  smoothBtn.onclick = ()=>{ const center=Math.floor((N-1)/2); smoothLocal(center, Math.floor(N/2), 2, 0.15); };
  saveBtn.onclick = ()=>{ downloadCanvas(canvas, 'torno-virtual.png'); flashSave(); };

  newTargetBtn.onclick = ()=>{ generateTarget(); updateScoreHint(); };
  okBtn.onclick = ()=>{ const res = evaluateAndExport(); showScore(res.acc); if(res.acc>=99.9){ setTimeout(()=> prize(), 50); } };

  function flashSave(){
    saveFeedback.style.display='block'; saveFeedback.style.animation='none'; void saveFeedback.offsetWidth; saveFeedback.style.animation='fade-out 1.2s forwards';
    setTimeout(()=>{ saveFeedback.style.display='none'; }, 1200);
  }
  function downloadCanvas(canv, name){
    const link = document.createElement('a'); link.download = name; link.href = canv.toDataURL('image/png'); link.click();
  }

  // Atalhos de teclado
  window.addEventListener('keydown', (e)=>{
    const k=e.key;
    if ((e.ctrlKey||e.metaKey) && !e.shiftKey && (k==='z'||k==='Z')){ e.preventDefault(); popUndo(); }
    else if ((e.ctrlKey||e.metaKey) && (k==='y'||k==='Y')){ e.preventDefault(); popRedo(); }
    else if ((e.ctrlKey||e.metaKey) && e.shiftKey && (k==='z'||k==='Z')){ e.preventDefault(); popRedo(); }
  });

  // ==== Render
  let tPrev=0, spin=0;
  function draw(ts){
    const dt = Math.min(32, (ts - (tPrev||ts))) / 1000; tPrev=ts;
    const rpm = parseInt(speedEl.value,10); spin += (rpm * 2*Math.PI / 60) * dt;
    ctx.clearRect(0,0,W,H);
    drawGround(); drawWheel(spin); drawClay(spin);
    drawTargetPreview();
    requestAnimationFrame(draw);
  }
  function drawGround(){
    const g=ctx.createRadialGradient(W*0.5,H*0.98,20,W*0.5,H*1.02,Math.max(W,H));
    g.addColorStop(0,'rgba(0,0,0,0.0)'); g.addColorStop(1,'rgba(0,0,0,0.6)');
    ctx.fillStyle=g; ctx.fillRect(0,H*0.75,W,H*0.25);
  }
  function drawWheel(angle){
    const y=baseY+8; const R=Math.min(maxR*1.1,220);
    const grad=ctx.createRadialGradient(cx,y,R*0.2,cx,y,R); grad.addColorStop(0,'#323640'); grad.addColorStop(1,'#1a1d23');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.ellipse(cx,y,R,R*0.25,0,0,Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(cx,y); ctx.scale(1,0.25); ctx.rotate(angle);
    ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2;
    for(let i=0;i<10;i++){ ctx.rotate(Math.PI/5); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(R*0.9,0); ctx.stroke(); }
    ctx.restore();
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(cx,y,Math.min(r[0]*1.05,R*0.9),R*0.20,0,0,Math.PI*2); ctx.fill();
  }
  function drawClay(angle){
    const Rmax=Math.max(...r); const left=cx-Rmax-6, right=cx+Rmax+6;
    ctx.beginPath();
    for(let i=0;i<N;i++){ const x=cx-r[i]; const y=yOf(i); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    for(let i=N-1;i>=0;i--){ const x=cx+r[i]; const y=yOf(i); ctx.lineTo(x,y); }
    ctx.closePath();
    const c0='#5b463f',c1='#8f6f64',c2='#d5b8ad'; const center=0.5+0.42*Math.sin(angle*1.2);
    const g=ctx.createLinearGradient(left,0,right,0); const w=0.10;
    g.addColorStop(0.00,c0); g.addColorStop(Math.max(0.0,center-2.5*w),c1);
    g.addColorStop(Math.max(0.0,center-1.2*w),c2); g.addColorStop(Math.min(1.0,center+1.2*w),c1); g.addColorStop(1.00,c0);
    ctx.fillStyle=g; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.2; ctx.stroke();
    const rt=r[N-1]; const yt=yOf(N-1)-0.5;
    const eGrad=ctx.createRadialGradient(cx,yt,rt*0.2,cx,yt,rt);
    eGrad.addColorStop(0,'rgba(0,0,0,0.25)'); eGrad.addColorStop(1,'rgba(0,0,0,0.0)');
    ctx.fillStyle=eGrad; ctx.beginPath(); ctx.ellipse(cx,yt,rt,rt*0.18,0,0,Math.PI*2); ctx.fill();
  }

  function drawTargetPreview(){
    const pw = prevCanvas.width, ph = prevCanvas.height;
    prevCtx.setTransform(1,0,0,1,0,0);
    prevCtx.clearRect(0,0,pw,ph);
    // eixos da mini-pr√©via
    const mCx = pw*0.25;  // alvo √† esquerda
    const mCy = ph*0.85;
    const h = ph*0.72;
    const rmax = Math.max(...rTarget);
    const scaleR = (pw*0.23) / Math.max(1, rmax);
    prevCtx.strokeStyle = 'rgba(255,255,255,0.08)';
    prevCtx.strokeRect(0.5,0.5,pw-1,ph-1);

    // fun√ß√£o y de mini
    const yMini = (i)=> mCy - (i/(N-1))*h;
    // desenhar alvo
    prevCtx.beginPath();
    for(let i=0;i<N;i++){
      const x = mCx - rTarget[i]*scaleR;
      const y = yMini(i);
      if(i===0) prevCtx.moveTo(x,y); else prevCtx.lineTo(x,y);
    }
    for(let i=N-1;i>=0;i--){
      const x = mCx + rTarget[i]*scaleR;
      const y = yMini(i);
      prevCtx.lineTo(x,y);
    }
    prevCtx.closePath();
    const grad=prevCtx.createLinearGradient(mCx-80,0,mCx+80,0);
    grad.addColorStop(0,'#6e5a52'); grad.addColorStop(0.5,'#c8ad9f'); grad.addColorStop(1,'#6e5a52');
    prevCtx.fillStyle=grad; prevCtx.fill();
    prevCtx.lineWidth=1; prevCtx.strokeStyle='rgba(0,0,0,0.35)'; prevCtx.stroke();

    // contorno da sua pe√ßa (em linhas) como guia
    const rmaxU = Math.max(...r);
    const sU = (pw*0.23) / Math.max(1, rmaxU);
    prevCtx.beginPath();
    for(let i=0;i<N;i++){
      const x = pw*0.72 - r[i]*sU;
      const y = yMini(i);
      if(i===0) prevCtx.moveTo(x,y); else prevCtx.lineTo(x,y);
    }
    for(let i=N-1;i>=0;i--){
      const x = pw*0.72 + r[i]*sU;
      const y = yMini(i);
      prevCtx.lineTo(x,y);
    }
    prevCtx.closePath();
    prevCtx.strokeStyle='rgba(255,255,255,0.65)';
    prevCtx.lineWidth=1.2; prevCtx.stroke();

    // r√≥tulos
    prevCtx.fillStyle='rgba(255,255,255,0.6)';
    prevCtx.font='12px ui-sans-serif,system-ui';
    prevCtx.fillText('Alvo', mCx-20, 14);
    prevCtx.fillText('Sua pe√ßa', pw*0.72-28, 14);
  }

  // ==== Avalia√ß√£o + Export PNG
  function evaluateAndExport(){
    // Ajuste de escala: encontramos s que minimiza ||rU - s rT||_2
    let num=0, den=0;
    for(let i=0;i<N;i++){ num += r[i]*rTarget[i]; den += rTarget[i]*rTarget[i]; }
    const s = den>1e-6 ? (num/den) : 1.0;

    let rmsNum=0, rmsDen=0;
    for(let i=0;i<N;i++){
      const d = r[i] - s*rTarget[i];
      rmsNum += d*d;
      rmsDen += (s*rTarget[i])*(s*rTarget[i]);
    }
    const err = Math.sqrt( Math.max(0, rmsNum) / Math.max(1e-6, rmsDen) ); // 0 = perfeito
    let acc = Math.max(0, 100*(1 - err));
    if(acc>99.95) acc = 100.0; // arredonda perfeito

    // Criar PNG comparativo
    const w=1000, h=700;
    const off = document.createElement('canvas'); off.width=w; off.height=h;
    const g = off.getContext('2d');

    // fundo
    const back=g.createLinearGradient(0,0,0,h);
    back.addColorStop(0,'#0f1218'); back.addColorStop(1,'#0b0d12');
    g.fillStyle=back; g.fillRect(0,0,w,h);

    // t√≠tulos
    g.fillStyle='#eef2f7';
    g.font='700 22px Inter, ui-sans-serif, system-ui';
    g.fillText('Desafio de Forma ‚Äì Torno Virtual', 24, 40);
    g.font='14px Inter, ui-sans-serif, system-ui';
    g.fillStyle='rgba(238,242,247,0.8)';
    g.fillText('Alvo', 180, 70);
    g.fillText('Sua pe√ßa', w-320, 70);

    // √°reas
    const leftCx = 240, rightCx = w-240;
    const baseYpng = h-80;
    const hpng = 520;

    function drawProfile(ctx, cxp, arr, fillGrad=true){
      const rmax = Math.max(...arr);
      const scale = 180 / Math.max(1, rmax);
      const yP = i => baseYpng - (i/(N-1))*hpng;

      if(fillGrad){
        ctx.beginPath();
        for(let i=0;i<N;i++){ const x=cxp - arr[i]*scale; const y=yP(i); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        for(let i=N-1;i>=0;i--){ const x=cxp + arr[i]*scale; const y=yP(i); ctx.lineTo(x,y); }
        ctx.closePath();
        const grad = ctx.createLinearGradient(cxp-200,0,cxp+200,0);
        grad.addColorStop(0,'#6e5a52'); grad.addColorStop(0.5,'#c8ad9f'); grad.addColorStop(1,'#6e5a52');
        ctx.fillStyle=grad; ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.4; ctx.stroke();
      } else {
        ctx.beginPath();
        for(let i=0;i<N;i++){ const x=cxp - arr[i]*scale; const y=yP(i); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        for(let i=N-1;i>=0;i--){ const x=cxp + arr[i]*scale; const y=yP(i); ctx.lineTo(x,y); }
        ctx.closePath();
        ctx.strokeStyle='#eaeef5'; ctx.lineWidth=1.8; ctx.stroke();
      }
    }

    drawProfile(g, leftCx, rTarget, true);
    drawProfile(g, rightCx, r, true);

    // sobrepor contornos (alvo em ciano, usu√°rio em branco)
    function strokeOutline(ctx, cxp, arr, color){
      const rmax = Math.max(...arr);
      const scale = 180 / Math.max(1, rmax);
      const yP = i => baseYpng - (i/(N-1))*hpng;
      ctx.beginPath();
      for(let i=0;i<N;i++){ const x=cxp - arr[i]*scale; const y=yP(i); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      for(let i=N-1;i>=0;i--){ const x=cxp + arr[i]*scale; const y=yP(i); ctx.lineTo(x,y); }
      ctx.closePath();
      ctx.strokeStyle=color; ctx.lineWidth=2.2; ctx.stroke();
    }
    strokeOutline(g, leftCx, rTarget, 'rgba(79,209,197,0.9)');
    strokeOutline(g, rightCx, r, 'rgba(255,255,255,0.95)');

    // Nota
    const badge = acc>=80 ? (acc>=95 ? 'excelente' : 'boa') : 'iniciante';
    const col = acc>=95 ? '#49d17d' : (acc>=80 ? '#e2b14f' : '#ef6b6b');
    g.fillStyle='#eef2f7';
    g.font='700 28px Inter, ui-sans-serif, system-ui';
    g.fillText(`Precis√£o: ${acc.toFixed(1)}%`, 24, h-112);
    g.font='14px Inter, ui-sans-serif, system-ui';
    g.fillStyle='rgba(238,242,247,0.8)';
    g.fillText(`Semente do desafio: #${(targetSeed % 10000).toString().padStart(4,'0')}  |  N√≠vel: ${badge}`, 24, h-84);

    // call to action
    g.fillStyle='#eef2f7';
    g.font='16px Inter, ui-sans-serif, system-ui';
    g.fillText('Se acertar 100%, publique no Instagram marcando @cesaraugustobarbosa e ganhe 1 ano de assinatura gr√°tis', 24, h-52);

    // baixar
    const link = document.createElement('a');
    const fileAcc = Math.round(acc*10)/10;
    link.download = `desafio-forma_${fileAcc}pc.png`;
    link.href = off.toDataURL('image/png');
    link.click();

    return {acc, s};
  }

  function prize(){
    alert('üéâ PARAB√âNS! Voc√™ acertou 100%.\n\nPoste a imagem no Instagram e marque @cesaraugustobarbosa para mostrar sua conquista!');
  }

  function showScore(acc){
    const t = `Precis√£o: ${acc.toFixed(1)}%`;
    scoreChip.textContent = t;
    scoreChip.style.borderColor = acc>=95? 'rgba(73,209,125,0.4)' : (acc>=80?'rgba(226,177,79,0.4)':'rgba(239,107,107,0.4)');
    scoreChip.style.background = acc>=95? 'rgba(73,209,125,0.10)' : (acc>=80?'rgba(226,177,79,0.10)':'rgba(239,107,107,0.10)');
  }
  function updateScoreHint(){
    scoreChip.textContent = 'Tente copiar a forma-alvo e toque em ‚úÖ OK';
    scoreChip.style.borderColor = 'var(--btnBorder)';
    scoreChip.style.background = '#13161b';
  }

  // ==== Boot
  let initialized=false;
  window.addEventListener('resize', ()=>{
    const prevInit=initialized; initialized=false; resize(); initialized=prevInit;
    const suggestedBand=Math.round(Math.max(8, Math.min(28, heightPx*0.03)));
    const band=Math.max(4, Math.min(40, suggestedBand));
    const prev=parseInt(bandEl.value,10);
    if(!Number.isFinite(prev) || prev===14) bandEl.value=band;
  });
  heightEl.addEventListener('input', ()=>{
    const v=parseInt(heightEl.value,10)||100; heightScale=Math.max(0.5, Math.min(2.0, v/100));
    heightPx = baseHeightPx * heightScale;
  });

  resize();
  if(!initialized){ initShape(); pushUndo(); initialized=true; }
  generateTarget(); // cria primeiro alvo
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
